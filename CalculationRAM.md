### Примерный расчет расходуемой сервисом оперативной памяти.

В памяти хранятся следующие объекты:
- Объект Map с операциями, которые еще выполняются;
- Объект Map с преагрегатами;
- Объект Map с конфигурационой информацией по сервисам.
- Опционально Map'a с агрегатами.

Рассчитаем гипотетическое количество потребляемой памяти для каждой Map'ы.

#####1. Объем памяти, который может потреблять Map'a с операциями, которые еще выполняются.
 
Данная структура состоит из ключа (ID сервиса - строка) и значения - Map'ы с операциями, где в 
качестве ключа выступает ID операции (строка), а в качестве значения объект, содержащий 
ID сервиса, ID операции, время начала и время окончания операции, а так же признак ошибки.
Таком образом предположим, что Fault Detector будут использовать 10 сервисов, и 
нагрузка на каждый будет в среднем 100 уникальных операций в минуту, которые равномерно 
поступают в систему. Стоит понимать что для одной операции будет 2 внешних вызова - 
во время начала и завершения операции. Интересующий временной интервал (далее ВИ) 10 минут, 
а ожидаемое время выполнения 6 минут.

Таким образом максимально за 10 минут в 10 сервисах будет находится 10000 объектов, 
содержаших информацию о операциях. Сам объект ServiceEvent содержит следующие поля:
- String serviceId;
- String operationId;
- long startTime;
- long endTime;
- boolean error.

Начнем со строк. Класс String содержит следующие поля:
- final char value[];
- final int offset;
- final int count;
- int hash.

Подсчитаем размер:
- Заголовок -> 8 байт
- Поля int -> 4 байта * 3 == 12 байт
- Ссылочная переменная на объект массива -> 4 байта


Итого: 24 байта. 

Так как строка содержит ссылку на массив символов, то, по сути, мы имеем дело с двумя 
разными объектами — объектом класса String и самим массивом, который хранит строку, 
а это еще 12 байт на сам объект массива + 2 байта на каждый символ строки. Ну и, 
конечно же, не забываем добавлять выравнивание для кратности 8 байтам.

Таким образом объект **String serviceId = "service_id_1234"** будет занимать следующее 
количество памяти.

Для "new String()":
- Заголовок: 8 байт
- Поля int: 4 байта * 3 == 12 байт
- Ссылочная переменная на объект массива: 4 байта
Итого: 24 байта

Для "new char[1]":
- Заголовок: 8 байт + 4 байта на длину массива == 12 байт
- Примитивы char: 2 байта * 15 == 30 байт
- Выравнивание для кратности 8 : 6 байт
Итого: 48 байта

В итоге new String("service_id") == 72 байт.

Будем считать, что длина operationId будет равна так же 15 символам или 72 байтам.

Примитив типа long занимает 8 байт, а boolean 1 байт. Таким образом размер одного объекта 
ServiceEvent будет расчитываться из следующих параметров:
- String serviceId = 72 байта;
- String operationId = 72 байта;
- long startTime = 8 байт;
- long endTime = 8 байт;
- boolean error = 1 байт;
- Заголовок: 8 байт.

Итого: 169 байт + 7 байт для выравнивания = 176 байт на каждый объект ServiceEvent. 
Также минимум 4 байта на ссылку на объект в Map'e. Таким образом минимальный размер 
оперативной памяти, который понадобится на хранение 10000 элементов будет равен 
1 800 000 байт или 1,72 мегабайта.

Если же закладываться на предполагаемую нагрузку хотя бы а 50 операций в секунду, то 
для 10 сервисов в худшем случае будет храниться 300000 операций. Это 54 000 000 байт 
или 51.5 мегабайт. Ожидаемо, что с увеличением ВИ и количества сервисов в худшем случае 
можно упереться в размер RAM. Подобная маловероятна в обычной работе, так как 
подсчитываются преагрегаты, а успешные/сбойные операции сразу удаляются, но возможна 
при одновременном сбое всех сервисов. 

#####2. Объем памяти, который может потреблять Map'a с преагрегатами

Объект Map с преагрегатами похож на описанную ранее Map'y с операциями, поэтому перейду
сразу к основному - объекту ServicePreAggregates. Он содержит следующие поля:
- String serviceId = 72 байт;
- String timeMark = 72 байт;
- long aggregationTime = 8 байт;
- int operationsCount = 4 байт;
- int runningOperationsCount = 4 байт;
- int hoveringOperationsCount = 4 байт;
- int errorOperationsCount = 4 байт;
- int successOperationsCount = 4 байт;
- Заголовок: 8 байт.

Итого: 180 + 4 байта выравнивание = 184. Так же по 4 байта в качестве ссылки в Map'e.
Минимальный размер агрегата = 1 секунда. таким образом за 10 минут для 10 сервисов будет 
6000 агрегатов, что выразится в 1 128 000 байт или 1,08 мб.

 #####3. Объем памяти, который может потреблять Map'ы с конфигурацией и агрегатами.
 
 Для каждого сервиса существует строго 1 агрегат и строго 1 конфигурация. Размер 
 данных структур в сравнении со структурами представленными ранее является ничтожным
 и не требует рассчета.
  